
//#extension GL_ARB_compute_variable_group_size: enable
#define WORK_GROUP_SIZE 256
#define SORT_SIZE 512
#define HALF_SIZE (SORT_SIZE/2)
#define ITERATIONS (HALF_SIZE > 1024 ? HALF_SIZE/1024 : 1)
#define NUM_THREADS	(HALF_SIZE/ITERATIONS)

struct ParticleState
{
	vec4 pos;
	vec4 vel;
	vec4 rot;
	vec4 accLife;
	vec4 color;
};

layout(std430, binding=4) buffer source 
{
	ParticleState settings[]; // array of structures
} pSettings;

layout(std430, binding=5) buffer StartSettings 
{
	ParticleState settings[]; // array of structures
} startSettings;

uniform sampler2D depthMap;

const float DT = 0.016;

layout( local_size_x = WORK_GROUP_SIZE,  local_size_y = 1, local_size_z = 1)   in;
void main()
{
	uint gid = gl_GlobalInvocationID.x;
	
	if(pSettings.settings[gid].accLife.w <= 0)
	{
		pSettings.settings[gid] = startSettings.settings[gid];
	}
	else
	{
		vec3 p  = pSettings.settings[gid].pos.xyz;
		vec3 v  = pSettings.settings[gid].vel.xyz;
		vec3 pp = p + (v*DT + 0.5*DT*DT*pSettings.settings[gid].accLife.xyz);
		vec3 vp = v + pSettings.settings[gid].accLife.xyz*DT;
		pSettings.settings[gid].pos = vec4(pp,1.0);
		pSettings.settings[gid].vel = vec4(vp,1.0);
		pSettings.settings[gid].accLife.w -= DT;
		if(pSettings.settings[gid].accLife.w <= 0.5)
		{
			pSettings.settings[gid].color -= 0.1;
		}
	}
	
	memoryBarrier();
	barrier();
	int i;
	// Bitonic sort
	for(int nMergeSize=2; nMergeSize <= SORT_SIZE; nMergeSize=nMergeSize*2 ) 
	{
		for(int nMergeSubSize=nMergeSize>>1; nMergeSubSize>0; nMergeSubSize=nMergeSubSize>>1 ) 
		{			
			for( i = 0; i<ITERATIONS; ++i )		
			{
				int tmp_index = int(gl_LocalInvocationIndex) + NUM_THREADS * i;
				int index_low = tmp_index & (nMergeSubSize-1);
				int index_high = 2*(tmp_index-index_low);
				int index = index_high + index_low;

				int nSwapElem = nMergeSubSize==nMergeSize>>1 ? index_high + (2*nMergeSubSize-1) - index_low : index_high + nMergeSubSize + index_low;
				if( nSwapElem < WORK_GROUP_SIZE )
				{
					ParticleState a = pSettings.settings[index];
					ParticleState b = pSettings.settings[nSwapElem];

					if( a.pos.z > b.pos.z )
					{ 
						pSettings.settings[index] = b;
						pSettings.settings[nSwapElem] = a;
					}
				}
				memoryBarrier();
				barrier();
			}
		}
	} 
	memoryBarrier();
	barrier();

}

