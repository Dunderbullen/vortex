uniform sampler2D depthMap;
//uniform vec3 Offset;

layout (r32f) uniform image2D coneMap;

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;
void main() 
{
	ivec2 location = ivec2(gl_GlobalInvocationID.xy);
	ivec2 itemID = ivec2(gl_LocalInvocationID.xy);
	ivec2 tileID = ivec2(gl_WorkGroupID.xy);
	ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);
	uint index = tileID.y * tileNumber.x + tileID.x;
	uint threadCount = TILE_SIZE * TILE_SIZE;
	uint passCount = ((ScreenSize.x * ScreenSize.y) + threadCount - 1) / threadCount;

	
	ivec2 TexCoord = ivec2(location) / ScreenSize;
	
	const int search_steps = 128;  
	vec3 src = vec3(TexCoord, 0.0f);  // Source texel  
	vec3 dst = src;  // Destination texel + offset?
	dst.z = texture(depthMap, dst.xy).r;  // Set dest. depth  
	vec3 vec = dst - src; // Ray direction  
	vec /= vec.z;  // Scale ray direction so that vec.z = 1.0  
	vec *= 1.0 - dst.z;  // Scale again  
	vec3 step_fwd = vec/search_steps;  // Length of a forward step  
	
	// Search until a new point outside the surface  
	vec3 ray_pos = dst + step_fwd;  
	
	for (int i = 1; i < search_steps; i++)
	{  
		float current_depth = texture(depthMap, ray_pos.xy).w;  
		if ( current_depth <= ray_pos.z )  
		{
			ray_pos += step_fwd;  
		}
	}  
	
	// Original texel depth  
	float src_texel_depth = texture(depthMap, TexCoord).w;  
	// Compute the cone ratio  
	float cone_ratio = (ray_pos.z >= src_texel_depth) ? 1.0 : length(ray_pos.xy - TexCoord) / (src_texel_depth - ray_pos.z);  
						
	// Check for minimum value with previous pass result  
	float best_ratio = imageLoad(coneMap, TexCoord).x;  
	
	if (cone_ratio > best_ratio)
	{
		cone_ratio = best_ratio;
	}
	
	float pixelColor = cone_ratio;
	
	imageStore(coneMap, TexCoord, vec4(pixelColor));
}